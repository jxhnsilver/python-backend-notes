from typing import List, Dict, Any, Tuple

# ==================================================
# 1. Генераторы списков (list comprehensions)
# ==================================================

# ✅ Фильтрация + преобразование (часто в API или обработке данных)
prices = [100, 200, 300, 400]
discounted = [p * 0.9 for p in prices if p > 150]  # → [180.0, 270.0, 360.0]
print("Со скидкой:", discounted)

# ✅ Список словарей → плоский список (например, для экспорта)
orders = [
    {"id": 1, "items": ["A", "B"]},
    {"id": 2, "items": ["C"]},
]
all_items = [item for order in orders for item in order["items"]]
print("Все товары:", all_items)  # → ['A', 'B', 'C']

# ==================================================
# 2. Генераторы словарей (dict comprehensions)
# ==================================================

# ✅ Инвертировать словарь (например, для маппинга ID ↔ name)
user_ids = {"Илья": "U1", "Анна": "U2"}
id_to_name = {v: k for k, v in user_ids.items()}
print("По ID:", id_to_name)  # → {'U1': 'Илья', 'U2': 'Анна'}

# ✅ Фильтрация словаря по значению
data = {"a": 1, "b": 5, "c": 3}
big_values = {k: v for k, v in data.items() if v > 3}
print("Больше 3:", big_values)  # → {'b': 5}

# ==================================================
# 3. Срезы (slices) — мощный инструмент
# ==================================================

items = [10, 20, 30, 40, 50]

# ✅ Последние N элементов (без ошибки, даже если N > len)
last_3 = items[-3:]  # → [30, 40, 50]
print("Последние 3:", last_3)

# ✅ Пропустить последний элемент (часто при парсинге)
without_last = items[:-1]  # → [10, 20, 30, 40]

# ✅ Каждый второй элемент (редко, но бывает)
evens = items[::2]  # → [10, 30, 50]

# ✅ Обратный порядок — без reversed()
reversed_items = items[::-1]  # → [50, 40, 30, 20, 10]

# ✅ Копия списка (а не ссылка!)
copy = items[:]  # лучше использовать items.copy(), но срез тоже работает

# ==================================================
# 4. Генераторы (generator expressions) — экономия памяти
# ==================================================

# ✅ Сумма квадратов без создания списка (мало памяти)
nums = range(1, 1000000)
total = sum(x * x for x in nums)  # ← генератор, не список!
print("Сумма квадратов (пример):", total % 1000)  # просто для вывода

# ✅ Проверка наличия условия (ленивое вычисление)
users = [{"name": "Илья", "active": True}, {"name": "Бот", "active": False}]
has_active = any(user["active"] for user in users)
print("Есть активные:", has_active)  # → True

# ==================================================
# 5. Полезные комбинации: zip, enumerate, срезы
# ==================================================

# ✅ Разделить список на пары (например, для batch-обработки)
def chunked(lst: List[Any], n: int) -> List[List[Any]]:
    """Разбить список на чанки по n элементов."""
    return [lst[i:i + n] for i in range(0, len(lst), n)]

print("Чанки по 2:", chunked([1, 2, 3, 4, 5], 2))  # → [[1,2], [3,4], [5]]

# ✅ Сопоставить индексы и значения (без range(len))
for i, value in enumerate(["a", "b", "c"], start=1):
    print(f"{i}: {value}")

# ✅ Объединить два списка в словарь
keys = ["name", "age"]
values = ["Илья", 25]
user = dict(zip(keys, values))
print("Из списков:", user)  # → {'name': 'Илья', 'age': 25}

# ==================================================
# 6. Безопасное получение элементов (часто в парсинге JSON)
# ==================================================

def safe_get_first(items: List[Any]) -> Any:
    """Безопасно получить первый элемент."""
    return items[0] if items else None

def safe_get_slice(items: List[Any], start: int, end: int) -> List[Any]:
    """Срез без IndexError."""
    return items[start:end]

# Пример
empty = []
print("Первый из пустого:", safe_get_first(empty))  # → None