
`list`  — это **динамический массив**, реализованный как **изменяемая упорядоченная коллекция объектов**. Он поддерживает **произвольный доступ по индексу** и **гетерогенные типы** (в один список можно положить всё что угодно).

### Основные характеристики `list`
| Свойство              | Значение                                                                                                       |
| --------------------- | -------------------------------------------------------------------------------------------------------------- |
| **Изменяемость**      | ✅ Да                                                                                                           |
| **Упорядоченность**   | ✅ Да (индексация с `0`)                                                                                        |
| **Дубликаты**         | ✅ Разрешены                                                                                                    |
| **Хранение в памяти** | В **heap** (куча), как и все объекты Python; сам список — это динамический массив указателей на объекты в куче |
| **Реализация**        | На C (в CPython) — массив указателей (`PyObject*`) с автоматическим расширением                                |
### Основные операции и методы
```python
lst = [1, 2, 3]

# Добавление
lst.append(4)        # O(1) амортизированно
lst.insert(0, 0)     # O(n) — сдвиг всех элементов

# Удаление
lst.pop()            # O(1) — удаление с конца
lst.pop(0)           # O(n) — сдвиг
lst.remove(2)        # O(n) — поиск + удаление

# Доступ и поиск
x = lst[2]           # O(1)
lst.index(3)         # O(n)

# Изменение
lst[1] = 99          # O(1)

# Длина
len(lst)             # O(1)

# Срезы
lst[1:3]             # O(k), где k — длина среза
```

| Операция           | Временная сложность  |
| ------------------ | -------------------- |
| `lst[i]`           | O(1)                 |
| `lst.append(x)`    | O(1) амортизированно |
| `lst.insert(i, x)` | O(n)                 |
| `lst.pop()`        | O(1)                 |
| `lst.pop(i)`       | O(n)                 |
| `x in lst`         | O(n)                 |
| `lst.index(x)`     | O(n)                 |
| `lst.copy()`       | O(n)                 |
| Срез `lst[a:b]`    | O(k)                 |
### Как хранится в памяти

- Внутри `list` — массив **указателей** (`PyObject*`) на объекты в куче.
- При добавлении элемента, если память исчерпана — выделяется **новый блок** (~1.125× больше), старые указатели копируются туда.
- Объекты **не хранятся внутри списка**, только ссылки на них.

```python
a = [1, "hello", []]
# a — список из 3 указателей:
# → int(1), str("hello"), list([])
```

### Когда использовать `list`

- Для **упорядоченных данных**
- Когда нужен **быстрый доступ по индексу**
- Когда часто **добавляете/удаляете с конца**
- Когда **не нужна гарантия уникальности**

> ⚠️ **Не используйте `list` как очередь** (`pop(0)` → O(n)). Для очереди — `collections.deque`

### Почему это "лучше"

- **Производительность**: `append`/`pop` с конца — O(1), что критично для стеков и буферов.
- **Читаемость**: интуитивный синтаксис, встроенные операции.
- **Гибкость**: поддержка срезов, итераций, comprehensions.
- **Соответствие SOLID**: инкапсулирует поведение коллекции, легко тестируем, подменяем (например, на `tuple` для неизменяемости).

Если нужна **очередь (FIFO)** — используй `collections.deque`.  
Если нужен **стек (LIFO)** — `list` идеален (`append` / `pop`).