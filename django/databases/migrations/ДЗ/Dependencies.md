`dependencies` — это список миграций, которые **должны быть применены до текущей**.

Django смотрит на этот список и **гарантирует порядок выполнения**: сначала запустятся указанные миграции, потом — текущая.

Нужно, чтобы не было ошибок вроде «таблицы не существует» — например, если миграция создаёт `ForeignKey`, то таблица, на которую он ссылается, должна уже быть в БД.
Формат:
```python
dependencies = [('app_name', '0001_initial')]
```
`dependencies` работают так:

1. При запуске `migrate` Django **собирает все миграции** из всех приложений.
2. Строит **граф зависимостей**: каждая миграция → список миграций, от которых она зависит.
3. Выполняет миграции **в порядке топологической сортировки** этого графа — то есть всегда **сначала зависимости, потом то, что от них зависит**.
4. Информация о том, какие миграции уже применены, берётся из таблицы `django_migrations` — повторно их не запускает.
Пример:  
Если миграция `books.0002` зависит от `authors.0001`, то:

- если `authors.0001` ещё не применена — Django применит её **сначала**,
- только потом — `books.0002`.

Если зависимость не указать — Django не узнает о связи, может применить миграции в неправильном порядке и выдать ошибку (например, `Foreign key references nonexistent table`).

Всё это происходит **автоматически** — зависимости добавляются при генерации миграции, если есть связи между моделями разных приложений.
### Конкретно зачем:

1. **Гарантия, что таблица существует до создания внешнего ключа**  
    Если миграция `books.0002` создаёт `ForeignKey` на модель из `authors`, то миграция `authors.0001` (которая создаёт эту таблицу) **должна быть применена раньше** — даже если обе миграции новые и ещё не запускались.
2. **Поддержка миграций из разных приложений**  
    Приложения не знают друг о друге, но модели могут быть связаны. Без зависимостей Django не узнал бы, в каком порядке применять миграции из `app1` и `app2`.
3. **Корректный откат (`migrate app N` назад)**  
    При откате тоже нужно знать, какие миграции зависят от текущей — иначе можно удалить таблицу, на которую другие ещё ссылаются.
4. **Работа в команде**  
    Два разработчика могут создать миграции в разных приложениях, но с кросс-зависимостями. Граф зависимостей позволяет Django правильно объединить и упорядочить их при развёртывании.

### Почему нужны зависимости?

Модели из разных приложений могут быть связаны (например, `ForeignKey` из `books` в `authors`).  
Чтобы БД не сломалась, **таблица, на которую ссылаются, должна существовать до создания внешнего ключа**.

Django автоматически добавляет **зависимости между миграциями**, чтобы:

- сначала создалась таблица `authors.Author`,
- затем — `books.Book` с `ForeignKey` на неё.
### Как это работает

- В файле миграции есть поле `dependencies`:
```python
dependencies = [
    ('authors', '0001_initial'),
]
```
- При запуске `migrate` Django строит **граф зависимостей** и применяет миграции в правильном порядке — даже между разными приложениями.
**Важно**:  
Ограничение миграций одним приложением (например, `migrate books`) — это **рекомендация, а не гарантия**.  
Если нужны зависимости из других приложений — они тоже будут применены.

### Ограничения

- **Приложения без миграций** (старые или неподдерживаемые) **не должны ссылаться** на модели из приложений **с миграциями**.  
    Такие связи могут иногда работать, но **не поддерживаются** и могут сломаться.

### Пример
```bash
# сначала для books
python manage.py makemigrations books

# потом для authors
python manage.py makemigrations authors
```
Но в `books/models.py` есть:
```python
author = models.ForeignKey('authors.Author', on_delete=models.CASCADE)
```
→ Тогда миграция `books.0001_initial` **автоматически получит зависимость** от `authors.0001_initial`,  
**даже если вы создали `books` раньше**.

Файл миграции будет содержать:
```python
dependencies = [('authors', '0001_initial')]
```
→ При `migrate` Django **сначала применит `authors.0001`**, потом `books.0001` — **в правильном логическом порядке**, а не в порядке создания файлов.
