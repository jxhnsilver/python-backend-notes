## Что такое кэш

**Кэш** — это **временное хранилище данных**, полученных в результате **ресурсоёмких операций** (запрос к БД, сложный расчёт, внешний API и т.п.), с целью **избежать повторного выполнения** этих операций при последующих запросах.

Кэш работает по принципу **ключ → значение**.
## Где хранится кэш

Кэш может храниться в **разных местах** — выбор определяет **производительность**, **надёжность** и **масштабируемость**:

|Тип кэша|Где физически хранится|Особенности|
|---|---|---|
|**In-memory (процесс)**|В RAM процесса Python (например, `LocMemCache`)|Быстро, но данные не общие между воркерами, теряются при перезапуске.|
|**In-memory (внешний)**|В RAM **отдельного процесса/сервера** (Redis, Memcached)|Быстро, данные общие для всех воркеров, масштабируется.|
|**File-based**|На диске (файлы в указанной директории)|Медленнее, но данные переживают перезапуск.|
|**Database**|В таблице СУБД|Самый медленный вариант — кэш медленнее, чем исходный запрос. Не рекомендуется.|
## Откуда берутся «серверы» кэша?

**Redis** и **Memcached** — это **отдельные программы (демоны)**, которые:
1. Запускаются **независимо от Django** (обычно как системный сервис: `redis-server`, `memcached`).
2. Слушают **сетевой порт** (например, Redis — `6379`, Memcached — `11211`) или Unix-сокет.
3. Предоставляют **протокол** для операций: `SET key value`, `GET key`, `DELETE key`.
4. Хранят все данные **только в оперативной памяти**.

Твой Django-процесс **подключается к ним по сети** (даже если на localhost) и использует их как **внешнее хранилище ключ-значение**.
Это **не «сервера кэша» в смысле твоего приложения**, а **отдельные инфраструктурные компоненты**, такие же, как PostgreSQL или RabbitMQ.
## Как это выглядит в коде (Django)

### 1. Настройка (settings.py)
```python
# Используем внешний in-memory кэш — Redis
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.redis.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/1",
    }
}
```
### 2. Использование
```python
from django.core.cache import cache

# Запись
cache.set("user_profile_123", {"name": "Alice", "role": "admin"}, timeout=300)

# Чтение
profile = cache.get("user_profile_123")
if profile is None:
    # Данных нет в кэше — делаем дорогую операцию
    profile = fetch_profile_from_db(123)
    cache.set(f"user_profile_{123}", profile, timeout=300)
```
## Ключевые свойства кэша

- **Временность**: данные **не предназначены для долгого хранения**. Могут быть удалены в любой момент (истечение TTL, нехватка памяти, перезапуск).
- **Не является источником правды**: всегда должна быть возможность **восстановить данные** из первоисточника (БД, API).
- **Требует управления ключами**: ключ должен однозначно идентифицировать данные (включая контекст: user_id, язык, версию и т.п.).
- **Требует инвалидации или TTL**: без этого кэш отдаёт устаревшие данные.
## Почему не хранить кэш в памяти самого Django?

При запуске Django через production-сервер (Gunicorn, Uvicorn) создаётся **несколько воркеров** (процессов).  
Каждый воркер — отдельный процесс с **собственной памятью**.  
→ Кэш в одном воркере **недоступен другим**.  
→ Это ломает логику кэширования.

**Внешний кэш (Redis/Memcached)** решает это: он **общий для всех воркеров**.
## Вывод

- Кэш — **оптимизация через временное хранение**.
- В продакшене кэш **всегда внешний** (Redis или Memcached).
- Redis/Memcached — **отдельные сервисы**, запущенные на сервере (локально или в облаке).
- Django подключается к ним **как клиент**, используя сетевой протокол.
- Кэш **никогда не заменяет основное хранилище** — только дополняет его.